// server/utils/pdfMemoryGuard.ts
// PDF generation memory leak protection
// Generated by Improvement Agent (2026-02-27)
// Resolves: P2 [Agent] Corriger memory leak dans PDF génération
//
// Problems found in pdfGeneratorV2.ts:
// 1. Puppeteer browser instances not closed on async errors (50-150MB leak each)
// 2. Base64 image accumulation without cleanup (10-15MB per request)
// 3. No concurrency limit on PDF generation (OOM under load)
// 4. No timeout protection for stalled PDF jobs
// 5. Missing stream error handlers leaving buffers orphaned

import { EventEmitter } from "events";
import { Request, Response, NextFunction } from "express";

// ============================================================================
// TYPES
// ============================================================================

interface PdfJobOptions {
  timeoutMs?: number;
  label?: string;
}

interface PdfJobStats {
  activeJobs: number;
  queuedJobs: number;
  completedJobs: number;
  failedJobs: number;
  totalTimeMs: number;
  peakMemoryMB: number;
}

type PdfGeneratorFn<T> = () => Promise<T>;

// ============================================================================
// PDF MEMORY GUARD — Singleton
// ============================================================================

class PdfMemoryGuard extends EventEmitter {
  private maxConcurrent: number;
  private timeoutMs: number;
  private memoryWarningMB: number;
  private activeJobs: number = 0;
  private queue: Array<{ resolve: Function; reject: Function }> = [];
  private stats: PdfJobStats = {
    activeJobs: 0,
    queuedJobs: 0,
    completedJobs: 0,
    failedJobs: 0,
    totalTimeMs: 0,
    peakMemoryMB: 0,
  };

  constructor(options?: {
    maxConcurrent?: number;
    timeoutMs?: number;
    memoryWarningMB?: number;
  }) {
    super();
    this.maxConcurrent = options?.maxConcurrent ?? 2;
    this.timeoutMs = options?.timeoutMs ?? 120_000; // 2 min default
    this.memoryWarningMB = options?.memoryWarningMB ?? 400;
  }

  /**
   * Execute a PDF generation function with concurrency control,
   * timeout protection, and memory monitoring.
   */
  async execute<T>(fn: PdfGeneratorFn<T>, options?: PdfJobOptions): Promise<T> {
    const timeout = options?.timeoutMs ?? this.timeoutMs;
    const label = options?.label ?? "pdf-job";

    // Wait for a slot if at capacity
    if (this.activeJobs >= this.maxConcurrent) {
      this.stats.queuedJobs++;
      await new Promise<void>((resolve, reject) => {
        const timer = setTimeout(() => {
          const idx = this.queue.findIndex((q) => q.resolve === resolve);
          if (idx >= 0) this.queue.splice(idx, 1);
          this.stats.queuedJobs = Math.max(0, this.stats.queuedJobs - 1);
          this.emit("deadlock", { label, queueSize: this.queue.length });
          reject(new Error(`PDF queue timeout: ${label} waited too long`));
        }, timeout);

        this.queue.push({
          resolve: () => { clearTimeout(timer); resolve(); },
          reject: (err: Error) => { clearTimeout(timer); reject(err); },
        });
      });
    }

    // Acquire slot
    this.activeJobs++;
    this.stats.activeJobs = this.activeJobs;
    const startTime = Date.now();

    // Check memory before starting
    this.checkMemory(label);

    try {
      // Execute with timeout
      const result = await Promise.race([
        fn(),
        new Promise<never>((_, reject) =>
          setTimeout(
            () => reject(new Error(`PDF generation timeout: ${label} exceeded ${timeout}ms`)),
            timeout
          )
        ),
      ]);

      this.stats.completedJobs++;
      this.stats.totalTimeMs += Date.now() - startTime;
      return result;
    } catch (error) {
      this.stats.failedJobs++;
      this.emit("error", { label, error, durationMs: Date.now() - startTime });
      throw error;
    } finally {
      // Release slot and process queue
      this.activeJobs--;
      this.stats.activeJobs = this.activeJobs;

      if (this.queue.length > 0) {
        const next = this.queue.shift()!;
        this.stats.queuedJobs = Math.max(0, this.stats.queuedJobs - 1);
        next.resolve();
      }

      // Force GC hint after large jobs
      if (global.gc) {
        try { global.gc(); } catch {}
      }
    }
  }

  /**
   * Express middleware wrapper for PDF endpoints.
   * Wraps the entire request handler in the memory guard.
   */
  middleware(handler: (req: Request, res: Response) => Promise<void>) {
    return async (req: Request, res: Response, next: NextFunction): Promise<void> => {
      try {
        await this.execute(
          () => handler(req, res),
          { label: `${req.method} ${req.path}` }
        );
      } catch (error) {
        next(error);
      }
    };
  }

  /**
   * Get current stats for monitoring/health checks.
   */
  getStats(): PdfJobStats {
    return { ...this.stats };
  }

  /**
   * Reset stats (for testing or after deployment).
   */
  resetStats(): void {
    this.stats = {
      activeJobs: this.activeJobs,
      queuedJobs: this.queue.length,
      completedJobs: 0,
      failedJobs: 0,
      totalTimeMs: 0,
      peakMemoryMB: 0,
    };
  }

  private checkMemory(label: string): void {
    const usage = process.memoryUsage();
    const heapMB = Math.round(usage.heapUsed / 1024 / 1024);
    const rssMB = Math.round(usage.rss / 1024 / 1024);

    if (heapMB > this.stats.peakMemoryMB) {
      this.stats.peakMemoryMB = heapMB;
    }

    if (rssMB > this.memoryWarningMB) {
      this.emit("memory-warning", {
        label,
        heapMB,
        rssMB,
        threshold: this.memoryWarningMB,
      });
      console.warn(
        `[PdfMemoryGuard] HIGH MEMORY: ${rssMB}MB RSS (threshold: ${this.memoryWarningMB}MB) during ${label}`
      );
    }
  }
}

// ============================================================================
// RESOURCE CLEANUP HELPERS
// ============================================================================

/**
 * Wraps a Puppeteer browser instance to ensure cleanup on any error.
 * Use this in pdfGeneratorV2.ts around browser.newPage() calls.
 */
export async function withBrowser<T>(
  launchFn: () => Promise<any>,
  taskFn: (browser: any) => Promise<T>
): Promise<T> {
  let browser: any = null;
  try {
    browser = await launchFn();
    return await taskFn(browser);
  } finally {
    if (browser) {
      try {
        await browser.close();
      } catch (closeErr) {
        console.error("[PdfMemoryGuard] Failed to close browser:", closeErr);
        // Force kill if close fails
        try { browser.process()?.kill("SIGKILL"); } catch {}
      }
    }
  }
}

/**
 * Wraps a Puppeteer page to ensure cleanup.
 */
export async function withPage<T>(
  browser: any,
  taskFn: (page: any) => Promise<T>
): Promise<T> {
  let page: any = null;
  try {
    page = await browser.newPage();
    return await taskFn(page);
  } finally {
    if (page) {
      try { await page.close(); } catch {}
    }
  }
}

/**
 * Safely collects a stream into a buffer with size limits.
 * Prevents unbounded memory growth from large PDFs.
 */
export function collectStream(
  stream: NodeJS.ReadableStream,
  maxSizeMB: number = 50
): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];
    let totalSize = 0;
    const maxBytes = maxSizeMB * 1024 * 1024;

    stream.on("data", (chunk: Buffer) => {
      totalSize += chunk.length;
      if (totalSize > maxBytes) {
        stream.destroy();
        reject(new Error(`PDF exceeds max size of ${maxSizeMB}MB`));
        return;
      }
      chunks.push(chunk);
    });

    stream.on("end", () => resolve(Buffer.concat(chunks)));
    stream.on("error", reject);
  });
}

// ============================================================================
// SINGLETON INSTANCE
// ============================================================================

/** Default guard: max 2 concurrent PDFs, 2min timeout, 400MB memory warning */
export const pdfGuard = new PdfMemoryGuard();

/** Export class for custom instances */
export { PdfMemoryGuard };
