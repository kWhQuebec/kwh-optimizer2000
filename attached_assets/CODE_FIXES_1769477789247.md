# kWh Optimizer 2000 - Comprehensive Code Fixes

This document contains all the code fixes identified during the code review. Copy each section to Replit to apply the fixes.

---

## Table of Contents

1. [New File: server/middleware/errorHandler.ts](#1-centralized-error-handler)
2. [New File: server/lib/secureRandom.ts](#2-secure-random-password-generation)
3. [New File: server/lib/config.ts](#3-centralized-config)
4. [Fix: server/routes/public.ts](#4-fix-payment-state-machine)
5. [Fix: server/routes/auth.ts](#5-fix-password-reset)
6. [Fix: server/routes/import.ts](#6-fix-n1-query)
7. [Fix: server/routes/admin.ts](#7-fix-path-traversal)
8. [Fix: server/routes/sites.ts](#8-fix-race-condition--file-uploads)
9. [Fix: shared/finance/cashflowEngine.ts](#9-fix-floating-point-precision)
10. [New File: server/lib/uploadConfig.ts](#10-centralized-upload-config)

---

## 1. Centralized Error Handler

**Create new file: `server/middleware/errorHandler.ts`**

```typescript
import { Request, Response, NextFunction } from "express";
import { ZodError } from "zod";

/**
 * Custom application error with status code
 */
export class AppError extends Error {
  public readonly statusCode: number;
  public readonly isOperational: boolean;
  public readonly details?: unknown;

  constructor(
    statusCode: number,
    message: string,
    isOperational = true,
    details?: unknown
  ) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.details = details;

    // Maintains proper stack trace for where error was thrown
    Error.captureStackTrace(this, this.constructor);
  }
}

/**
 * Common error factory methods
 */
export const Errors = {
  badRequest: (message: string, details?: unknown) =>
    new AppError(400, message, true, details),

  unauthorized: (message = "Unauthorized") =>
    new AppError(401, message),

  forbidden: (message = "Access denied") =>
    new AppError(403, message),

  notFound: (resource = "Resource") =>
    new AppError(404, `${resource} not found`),

  conflict: (message: string, details?: unknown) =>
    new AppError(409, message, true, details),

  internal: (message = "Internal server error") =>
    new AppError(500, message, false),
};

/**
 * Async route handler wrapper - catches errors and forwards to error handler
 */
export function asyncHandler(
  fn: (req: Request, res: Response, next: NextFunction) => Promise<void | Response>
) {
  return (req: Request, res: Response, next: NextFunction) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}

/**
 * Global error handler middleware
 * Must be registered LAST in Express middleware chain
 */
export function errorHandler(
  err: Error,
  req: Request,
  res: Response,
  _next: NextFunction
): void {
  // Log error with context
  console.error({
    timestamp: new Date().toISOString(),
    error: err.message,
    stack: err.stack,
    path: req.path,
    method: req.method,
    userId: (req as any).userId || "anonymous",
    body: req.method !== "GET" ? "[redacted]" : undefined,
  });

  // Handle known error types
  if (err instanceof AppError) {
    res.status(err.statusCode).json({
      error: err.message,
      ...(err.details && { details: err.details }),
    });
    return;
  }

  if (err instanceof ZodError) {
    res.status(400).json({
      error: "Validation failed",
      details: err.errors.map((e) => ({
        path: e.path.join("."),
        message: e.message,
      })),
    });
    return;
  }

  // Handle Stripe errors
  if (err.name === "StripeError" || (err as any).type?.startsWith("Stripe")) {
    res.status(402).json({
      error: "Payment processing error",
      details: err.message,
    });
    return;
  }

  // Handle database errors (Drizzle/Postgres)
  if (err.message?.includes("duplicate key") || err.message?.includes("unique constraint")) {
    res.status(409).json({
      error: "A record with this information already exists",
    });
    return;
  }

  // Don't leak internal errors in production
  res.status(500).json({
    error: "Internal server error",
  });
}

/**
 * 404 handler for undefined routes
 */
export function notFoundHandler(req: Request, res: Response): void {
  res.status(404).json({
    error: `Route ${req.method} ${req.path} not found`,
  });
}
```

**Then update `server/index.ts` (or wherever Express is configured):**

```typescript
import { errorHandler, notFoundHandler } from "./middleware/errorHandler";

// ... all your routes ...

// Add these LAST, after all routes
app.use(notFoundHandler);
app.use(errorHandler);
```

---

## 2. Secure Random Password Generation

**Create new file: `server/lib/secureRandom.ts`**

```typescript
import crypto from "crypto";

/**
 * Generate cryptographically secure random string without modulo bias
 * Uses rejection sampling to ensure uniform distribution
 */
export function generateSecurePassword(length: number = 12): string {
  const charset = "ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz23456789";
  const charsetLength = charset.length;

  // Calculate the largest multiple of charsetLength that fits in a byte
  // This eliminates modulo bias
  const maxValid = Math.floor(256 / charsetLength) * charsetLength;

  let result = "";

  while (result.length < length) {
    const randomBytes = crypto.randomBytes(length - result.length);

    for (const byte of randomBytes) {
      // Reject bytes that would cause modulo bias
      if (byte < maxValid) {
        result += charset[byte % charsetLength];
        if (result.length === length) break;
      }
    }
  }

  return result;
}

/**
 * Generate a secure token for password reset links
 * Returns URL-safe base64 string
 */
export function generateResetToken(): string {
  return crypto.randomBytes(32).toString("base64url");
}

/**
 * Generate a short numeric verification code
 */
export function generateVerificationCode(digits: number = 6): string {
  const max = Math.pow(10, digits);
  const randomNumber = crypto.randomInt(0, max);
  return randomNumber.toString().padStart(digits, "0");
}
```

---

## 3. Centralized Config

**Create new file: `server/lib/config.ts`**

```typescript
import { z } from "zod";

/**
 * Environment variable schema with validation
 */
const envSchema = z.object({
  // Required
  SESSION_SECRET: z.string().min(32, "SESSION_SECRET must be at least 32 characters"),
  DATABASE_URL: z.string().url("DATABASE_URL must be a valid URL"),

  // Optional with defaults
  NODE_ENV: z.enum(["development", "production", "test"]).default("development"),
  PORT: z.string().transform(Number).default("3000"),

  // Optional API keys
  AI_INTEGRATIONS_GEMINI_API_KEY: z.string().optional(),
  AI_INTEGRATIONS_GEMINI_BASE_URL: z.string().url().optional(),
  STRIPE_SECRET_KEY: z.string().optional(),
  STRIPE_PUBLISHABLE_KEY: z.string().optional(),
  GOOGLE_SOLAR_API_KEY: z.string().optional(),

  // Replit-specific
  REPLIT_DOMAINS: z.string().optional(),
  REPL_SLUG: z.string().optional(),

  // Email
  GMAIL_USER: z.string().email().optional(),
  GMAIL_APP_PASSWORD: z.string().optional(),
  RESEND_API_KEY: z.string().optional(),
});

type EnvConfig = z.infer<typeof envSchema>;

function loadConfig(): EnvConfig {
  const result = envSchema.safeParse(process.env);

  if (!result.success) {
    console.error("❌ Invalid environment configuration:");
    console.error(result.error.format());
    process.exit(1);
  }

  return result.data;
}

// Load and validate config at startup
export const config = loadConfig();

// Type-safe config accessors
export const isProduction = config.NODE_ENV === "production";
export const isDevelopment = config.NODE_ENV === "development";

/**
 * Get base URL for the application
 */
export function getBaseUrl(): string {
  if (config.REPLIT_DOMAINS) {
    const domain = config.REPLIT_DOMAINS.split(",")[0];
    return `https://${domain}`;
  }
  return `http://localhost:${config.PORT}`;
}
```

---

## 4. Fix Payment State Machine

**Replace `server/routes/public.ts` with this fixed version:**

The key changes:
1. Added proper status states: `pending`, `signed`, `payment_pending`, `paid`, `expired`
2. Prevent overwriting signature on checkout creation
3. Validate session belongs to agreement before confirming
4. Add email validation

```typescript
import { Router, Request, Response } from "express";
import { z } from "zod";
import { storage } from "../storage";
import { AppError, Errors, asyncHandler } from "../middleware/errorHandler";

const router = Router();

// Valid agreement status transitions
type AgreementStatus = "pending" | "signed" | "payment_pending" | "paid" | "expired";

const emailSchema = z.string().email("Invalid email format");

router.get("/api/public/agreements/:token", asyncHandler(async (req, res) => {
  const { token } = req.params;

  // Use indexed lookup instead of fetching all agreements
  const agreement = await storage.getDesignAgreementByToken(token);

  if (!agreement) {
    throw Errors.notFound("Agreement");
  }

  // Check expiration first
  if (agreement.validUntil && new Date(agreement.validUntil) < new Date()) {
    // Update status if not already expired
    if (agreement.status !== "expired") {
      await storage.updateDesignAgreement(agreement.id, { status: "expired" });
    }
    throw new AppError(410, "Agreement has expired");
  }

  const site = await storage.getSite(agreement.siteId);
  if (!site) {
    throw Errors.notFound("Site");
  }

  const client = await storage.getClient(site.clientId);
  if (!client) {
    throw Errors.notFound("Client");
  }

  res.json({
    id: agreement.id,
    status: agreement.status,
    validUntil: agreement.validUntil,
    quotedCosts: agreement.quotedCosts,
    totalCad: agreement.totalCad,
    paymentTerms: agreement.paymentTerms,
    acceptedAt: agreement.acceptedAt,
    acceptedByName: agreement.acceptedByName,
    site: {
      name: site.name,
      address: site.address,
      city: site.city,
      province: site.province,
    },
    client: {
      name: client.name,
      email: client.email,
    },
  });
}));

router.post("/api/public/agreements/:token/sign", asyncHandler(async (req, res) => {
  const { token } = req.params;
  const { name, email, signatureData } = req.body;

  // Validate inputs
  if (!name || !email || !signatureData) {
    throw Errors.badRequest("Name, email, and signature are required");
  }

  // Validate email format
  const emailResult = emailSchema.safeParse(email);
  if (!emailResult.success) {
    throw Errors.badRequest("Invalid email format");
  }

  // Validate name length
  if (name.length > 200) {
    throw Errors.badRequest("Name is too long (max 200 characters)");
  }

  const agreement = await storage.getDesignAgreementByToken(token);

  if (!agreement) {
    throw Errors.notFound("Agreement");
  }

  // Check status - only pending agreements can be signed
  if (agreement.status !== "pending") {
    throw Errors.badRequest(`Agreement cannot be signed (current status: ${agreement.status})`);
  }

  // Check expiration
  if (agreement.validUntil && new Date(agreement.validUntil) < new Date()) {
    await storage.updateDesignAgreement(agreement.id, { status: "expired" });
    throw new AppError(410, "Agreement has expired");
  }

  const updated = await storage.updateDesignAgreement(agreement.id, {
    status: "signed",
    acceptedAt: new Date(),
    acceptedByName: name.trim(),
    acceptedByEmail: emailResult.data.toLowerCase(),
    signatureData: signatureData,
  });

  res.json({ success: true, agreement: updated });
}));

router.post("/api/public/agreements/:token/create-checkout", asyncHandler(async (req, res) => {
  const { token } = req.params;
  const { language = "fr" } = req.body;

  const agreement = await storage.getDesignAgreementByToken(token);

  if (!agreement) {
    throw Errors.notFound("Agreement");
  }

  // Only signed agreements can proceed to payment
  if (agreement.status !== "signed") {
    throw Errors.badRequest(
      agreement.status === "pending"
        ? "Agreement must be signed before payment"
        : `Agreement cannot proceed to payment (current status: ${agreement.status})`
    );
  }

  // Verify signature exists (should always be true if status is "signed")
  if (!agreement.signatureData || !agreement.acceptedByEmail) {
    throw Errors.badRequest("Agreement signature is missing");
  }

  // Check expiration
  if (agreement.validUntil && new Date(agreement.validUntil) < new Date()) {
    await storage.updateDesignAgreement(agreement.id, { status: "expired" });
    throw new AppError(410, "Agreement has expired");
  }

  const site = await storage.getSite(agreement.siteId);
  if (!site) {
    throw Errors.notFound("Site");
  }

  const client = await storage.getClient(site.clientId);
  if (!client) {
    throw Errors.notFound("Client");
  }

  const totalAmount = agreement.totalCad || 0;
  if (totalAmount <= 0) {
    throw Errors.badRequest("Invalid agreement total amount");
  }

  const depositAmount = Math.round(totalAmount * 0.5 * 100); // Convert to cents

  if (depositAmount <= 50) { // Stripe minimum is 50 cents
    throw Errors.badRequest("Deposit amount is too low");
  }

  const { getUncachableStripeClient } = await import("../stripeClient");
  const stripe = await getUncachableStripeClient();

  const baseUrl = process.env.REPLIT_DOMAINS
    ? `https://${process.env.REPLIT_DOMAINS.split(',')[0]}`
    : "http://localhost:3000";

  const session = await stripe.checkout.sessions.create({
    payment_method_types: ['card'],
    line_items: [{
      price_data: {
        currency: 'cad',
        unit_amount: depositAmount,
        product_data: {
          name: language === "fr"
            ? `Dépôt - Entente de design: ${site.name}`
            : `Deposit - Design Agreement: ${site.name}`,
          description: language === "fr"
            ? `Dépôt 50% pour les services de conception technique - ${client.name}`
            : `50% deposit for technical design services - ${client.name}`,
        },
      },
      quantity: 1,
    }],
    mode: 'payment',
    success_url: `${baseUrl}/sign/${token}?payment=success`,
    cancel_url: `${baseUrl}/sign/${token}?payment=cancelled`,
    customer_email: agreement.acceptedByEmail, // Use stored email, not from request
    metadata: {
      agreementId: agreement.id,
      agreementToken: token,
      signerName: agreement.acceptedByName,
      signerEmail: agreement.acceptedByEmail,
      siteId: agreement.siteId,
      clientId: site.clientId,
    },
    locale: language === "fr" ? "fr-CA" : "en",
  });

  // Update status to payment_pending - DO NOT overwrite signature
  await storage.updateDesignAgreement(agreement.id, {
    status: "payment_pending",
    stripeSessionId: session.id,
  });

  res.json({
    success: true,
    checkoutUrl: session.url,
    sessionId: session.id,
  });
}));

router.post("/api/public/agreements/:token/confirm-payment", asyncHandler(async (req, res) => {
  const { token } = req.params;
  const { sessionId } = req.body;

  if (!sessionId) {
    throw Errors.badRequest("Session ID is required");
  }

  const agreement = await storage.getDesignAgreementByToken(token);

  if (!agreement) {
    throw Errors.notFound("Agreement");
  }

  // Verify the session ID matches what we stored
  if (agreement.stripeSessionId !== sessionId) {
    throw Errors.badRequest("Session ID does not match this agreement");
  }

  // Only payment_pending agreements can be confirmed
  if (agreement.status !== "payment_pending") {
    throw Errors.badRequest(`Payment cannot be confirmed (current status: ${agreement.status})`);
  }

  const { getUncachableStripeClient } = await import("../stripeClient");
  const stripe = await getUncachableStripeClient();

  const session = await stripe.checkout.sessions.retrieve(sessionId);

  // Verify the session metadata matches
  if (session.metadata?.agreementId !== agreement.id) {
    throw Errors.badRequest("Session does not belong to this agreement");
  }

  if (session.payment_status !== 'paid') {
    throw Errors.badRequest("Payment not completed");
  }

  const depositAmount = (session.amount_total || 0) / 100;

  const updated = await storage.updateDesignAgreement(agreement.id, {
    status: "paid",
    depositAmount: depositAmount,
    depositPaidAt: new Date(),
    stripePaymentIntentId: session.payment_intent as string,
  });

  res.json({ success: true, agreement: updated });
}));

// ... rest of routes (portfolio, blog) unchanged ...

export default router;
```

**Important:** You'll also need to add a new method to `server/storage.ts`:

```typescript
// Add this method to the IStorage interface and implementation
async getDesignAgreementByToken(token: string): Promise<DesignAgreement | null> {
  const result = await db
    .select()
    .from(designAgreements)
    .where(eq(designAgreements.publicToken, token))
    .limit(1);
  return result[0] || null;
}
```

---

## 5. Fix Password Reset

**Replace the relevant section in `server/routes/auth.ts`:**

```typescript
import { Router, Response } from "express";
import { authMiddleware, signToken, AuthRequest } from "../middleware/auth";
import { storage } from "../storage";
import bcrypt from "bcrypt";
import { sendPasswordResetEmail } from "../emailService";
import { generateSecurePassword } from "../lib/secureRandom";
import { asyncHandler, Errors } from "../middleware/errorHandler";
import { z } from "zod";

const router = Router();

const emailSchema = z.string().email().transform(e => e.toLowerCase().trim());

// Rate limiting map (in production, use Redis)
const resetAttempts = new Map<string, { count: number; resetAt: number }>();
const MAX_RESET_ATTEMPTS = 5;
const RESET_WINDOW_MS = 15 * 60 * 1000; // 15 minutes

function checkRateLimit(email: string): boolean {
  const now = Date.now();
  const attempts = resetAttempts.get(email);

  if (!attempts || now > attempts.resetAt) {
    resetAttempts.set(email, { count: 1, resetAt: now + RESET_WINDOW_MS });
    return true;
  }

  if (attempts.count >= MAX_RESET_ATTEMPTS) {
    return false;
  }

  attempts.count++;
  return true;
}

router.post("/api/auth/forgot-password", asyncHandler(async (req, res) => {
  const { email, language = "fr" } = req.body;

  if (!email) {
    throw Errors.badRequest("Email is required");
  }

  // Validate and normalize email
  const emailResult = emailSchema.safeParse(email);
  if (!emailResult.success) {
    // Return success anyway to prevent email enumeration
    res.json({ success: true, message: "If an account exists, a password reset email has been sent." });
    return;
  }

  const normalizedEmail = emailResult.data;

  // Rate limiting
  if (!checkRateLimit(normalizedEmail)) {
    // Return success anyway to prevent timing attacks
    console.log(`[Forgot Password] Rate limited: ${normalizedEmail}`);
    res.json({ success: true, message: "If an account exists, a password reset email has been sent." });
    return;
  }

  const user = await storage.getUserByEmail(normalizedEmail);

  if (!user) {
    console.log(`[Forgot Password] No user found for email: ${normalizedEmail}`);
    // Return success anyway to prevent email enumeration
    res.json({ success: true, message: "If an account exists, a password reset email has been sent." });
    return;
  }

  // Generate secure temporary password
  const tempPassword = generateSecurePassword(14);

  const passwordHash = await bcrypt.hash(tempPassword, 10);

  await storage.updateUser(user.id, {
    passwordHash,
    forcePasswordChange: true,
    passwordResetAt: new Date(), // Track when reset was requested
  });

  // Use user's preferred language if available, otherwise use request language
  const emailLanguage = user.preferredLanguage || language;
  await sendPasswordResetEmail(user.email, tempPassword, emailLanguage);

  console.log(`[Forgot Password] Password reset email sent to: ${normalizedEmail}`);

  res.json({ success: true, message: "If an account exists, a password reset email has been sent." });
}));

// ... rest of auth routes unchanged ...

export default router;
```

---

## 6. Fix N+1 Query

**Replace the client import section in `server/routes/import.ts`:**

```typescript
router.post("/api/import/clients", authMiddleware, requireStaff, asyncHandler(async (req: AuthRequest, res) => {
  const { items } = req.body;

  if (!Array.isArray(items) || items.length === 0) {
    throw Errors.badRequest("No items provided");
  }

  // FIX: Fetch clients ONCE before the loop
  const existingClients = await storage.getClients();
  const clientsByName = new Map(
    existingClients.map(c => [c.name.toLowerCase().trim(), c])
  );

  let created = 0;
  let updated = 0;
  const errors: { index: number; error: string }[] = [];

  for (let i = 0; i < items.length; i++) {
    try {
      const item = items[i];

      if (!item.name || typeof item.name !== 'string' || item.name.trim() === '') {
        errors.push({ index: i, error: "Missing required field: name" });
        continue;
      }

      const normalizedName = item.name.toLowerCase().trim();
      const existingClient = clientsByName.get(normalizedName);

      if (existingClient) {
        await storage.updateClient(existingClient.id, {
          contactName: item.contactName?.trim() || existingClient.contactName,
          email: item.email?.trim() || existingClient.email,
          phone: item.phone?.trim() || existingClient.phone,
          address: item.address?.trim() || existingClient.address,
          city: item.city?.trim() || existingClient.city,
          province: item.province?.trim() || existingClient.province,
          postalCode: item.postalCode?.trim() || existingClient.postalCode,
          notes: item.notes?.trim() || existingClient.notes,
        });
        updated++;
      } else {
        const newClient = await storage.createClient({
          name: item.name.trim(),
          contactName: item.contactName?.trim() || null,
          email: item.email?.trim() || null,
          phone: item.phone?.trim() || null,
          address: item.address?.trim() || null,
          city: item.city?.trim() || null,
          province: item.province?.trim() || "Québec",
          postalCode: item.postalCode?.trim() || null,
          notes: item.notes?.trim() || null,
        });
        // Add to map for subsequent iterations
        clientsByName.set(normalizedName, newClient);
        created++;
      }
    } catch (err) {
      errors.push({ index: i, error: err instanceof Error ? err.message : "Unknown error" });
    }
  }

  res.json({
    created,
    updated,
    skipped: 0,
    errors: errors.length,
    errorDetails: errors,
  });
}));

// Apply same pattern to catalog import
router.post("/api/import/catalog", authMiddleware, requireStaff, asyncHandler(async (req: AuthRequest, res) => {
  const { items } = req.body;

  if (!Array.isArray(items) || items.length === 0) {
    throw Errors.badRequest("No items provided");
  }

  // FIX: Fetch catalog ONCE before the loop
  const existingCatalog = await storage.getCatalog();
  const catalogByKey = new Map(
    existingCatalog.map(c => [
      `${c.manufacturer.toLowerCase().trim()}|${c.model.toLowerCase().trim()}`,
      c
    ])
  );

  let created = 0;
  let updated = 0;
  const errors: { index: number; error: string }[] = [];

  for (let i = 0; i < items.length; i++) {
    try {
      const item = items[i];

      if (!item.category?.trim() || !item.manufacturer?.trim() || !item.model?.trim()) {
        errors.push({ index: i, error: "Missing required fields (category, manufacturer, model)" });
        continue;
      }

      const key = `${item.manufacturer.toLowerCase().trim()}|${item.model.toLowerCase().trim()}`;
      const existingItem = catalogByKey.get(key);

      let specJson = item.specJson;
      if (typeof specJson === 'string' && specJson.trim()) {
        try {
          specJson = JSON.parse(specJson);
        } catch {
          specJson = null;
        }
      }

      const unitCost = item.unitCost ? parseFloat(String(item.unitCost)) : null;
      const unitSellPrice = item.unitSellPrice ? parseFloat(String(item.unitSellPrice)) : null;
      const active = item.active !== undefined ? Boolean(item.active) : true;

      if (existingItem) {
        await storage.updateCatalogItem(existingItem.id, {
          category: item.category.trim().toUpperCase(),
          specJson: specJson || existingItem.specJson,
          unitCost: unitCost !== null && !isNaN(unitCost) ? unitCost : existingItem.unitCost,
          unitSellPrice: unitSellPrice !== null && !isNaN(unitSellPrice) ? unitSellPrice : existingItem.unitSellPrice,
          active,
        });
        updated++;
      } else {
        const newItem = await storage.createCatalogItem({
          category: item.category.trim().toUpperCase(),
          manufacturer: item.manufacturer.trim(),
          model: item.model.trim(),
          specJson: specJson || null,
          unitCost: unitCost !== null && !isNaN(unitCost) ? unitCost : null,
          unitSellPrice: unitSellPrice !== null && !isNaN(unitSellPrice) ? unitSellPrice : null,
          active,
        });
        catalogByKey.set(key, newItem);
        created++;
      }
    } catch (err) {
      errors.push({ index: i, error: err instanceof Error ? err.message : "Unknown error" });
    }
  }

  res.json({
    created,
    updated,
    skipped: 0,
    errors: errors.length,
    errorDetails: errors,
  });
}));
```

---

## 7. Fix Path Traversal

**Replace the procuration download route in `server/routes/admin.ts`:**

```typescript
import path from "path";

router.get("/api/admin/procuration-pdfs/:filename", authMiddleware, requireStaff, asyncHandler(async (req: AuthRequest, res: Response) => {
  const { filename } = req.params;

  // FIX: Use path.basename to extract just the filename, preventing any traversal
  const sanitizedFilename = path.basename(filename);

  // Additional validation: only allow PDF files with safe characters
  if (!/^[a-zA-Z0-9_\-]+\.pdf$/.test(sanitizedFilename)) {
    throw Errors.badRequest("Invalid filename format");
  }

  const uploadsDir = path.resolve(process.cwd(), "uploads", "procurations");
  const filePath = path.join(uploadsDir, sanitizedFilename);

  // FIX: Verify the resolved path is still within uploads directory
  if (!filePath.startsWith(uploadsDir)) {
    throw Errors.badRequest("Invalid file path");
  }

  if (!fs.existsSync(filePath)) {
    throw Errors.notFound("File");
  }

  res.setHeader("Content-Type", "application/pdf");
  res.setHeader("Content-Disposition", `attachment; filename="${sanitizedFilename}"`);
  res.sendFile(filePath);
}));
```

---

## 8. Fix Race Condition & File Uploads

**Create new file: `server/lib/uploadConfig.ts`**

```typescript
import multer from "multer";
import path from "path";
import crypto from "crypto";
import fs from "fs";

// Ensure upload directories exist
const UPLOAD_BASE = process.cwd();
const METER_UPLOADS_DIR = path.join(UPLOAD_BASE, "uploads", "meters");
const SITE_VISIT_DIR = path.join(UPLOAD_BASE, "uploads", "site-visits");
const PROCURATIONS_DIR = path.join(UPLOAD_BASE, "uploads", "procurations");
const SIGNATURES_DIR = path.join(UPLOAD_BASE, "uploads", "signatures");

[METER_UPLOADS_DIR, SITE_VISIT_DIR, PROCURATIONS_DIR, SIGNATURES_DIR].forEach(dir => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
});

/**
 * Generate unique filename to prevent collisions
 */
function generateUniqueFilename(originalname: string): string {
  const ext = path.extname(originalname);
  const timestamp = Date.now();
  const random = crypto.randomBytes(8).toString("hex");
  return `${timestamp}-${random}${ext}`;
}

/**
 * Multer storage with size limits and unique filenames
 */
export const meterUpload = multer({
  storage: multer.diskStorage({
    destination: METER_UPLOADS_DIR,
    filename: (req, file, cb) => cb(null, generateUniqueFilename(file.originalname)),
  }),
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
    files: 1,
  },
  fileFilter: (req, file, cb) => {
    const allowedMimes = ["text/csv", "application/vnd.ms-excel", "text/plain"];
    if (allowedMimes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error("Invalid file type. Only CSV files are allowed."));
    }
  },
});

export const siteVisitUpload = multer({
  storage: multer.diskStorage({
    destination: SITE_VISIT_DIR,
    filename: (req, file, cb) => cb(null, generateUniqueFilename(file.originalname)),
  }),
  limits: {
    fileSize: 25 * 1024 * 1024, // 25MB for photos
    files: 20,
  },
  fileFilter: (req, file, cb) => {
    const allowedMimes = ["image/jpeg", "image/png", "image/webp", "image/heic"];
    if (allowedMimes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error("Invalid file type. Only JPEG, PNG, WebP and HEIC images are allowed."));
    }
  },
});

/**
 * Safe file deletion helper
 */
export async function safeDeleteFile(filePath: string): Promise<void> {
  try {
    await fs.promises.unlink(filePath);
  } catch (error) {
    // Log but don't throw - file might already be deleted
    console.warn(`Could not delete file ${filePath}:`, error);
  }
}

/**
 * Cleanup old temp files (call periodically)
 */
export async function cleanupOldUploads(maxAgeMs: number = 24 * 60 * 60 * 1000): Promise<number> {
  let deleted = 0;
  const now = Date.now();

  for (const dir of [METER_UPLOADS_DIR, SITE_VISIT_DIR]) {
    try {
      const files = await fs.promises.readdir(dir);

      for (const file of files) {
        const filePath = path.join(dir, file);
        const stats = await fs.promises.stat(filePath);

        if (now - stats.mtimeMs > maxAgeMs) {
          await safeDeleteFile(filePath);
          deleted++;
        }
      }
    } catch (error) {
      console.error(`Error cleaning up ${dir}:`, error);
    }
  }

  return deleted;
}
```

**Add roof estimation locking in `server/routes/sites.ts`:**

```typescript
// Add at top of file
const roofEstimationLocks = new Map<string, boolean>();

async function triggerRoofEstimation(siteId: string): Promise<void> {
  // Check if estimation is already in progress
  if (roofEstimationLocks.get(siteId)) {
    console.log(`Roof estimation already in progress for site ${siteId}`);
    return;
  }

  // Acquire lock
  roofEstimationLocks.set(siteId, true);

  try {
    const site = await storage.getSite(siteId);
    if (!site) {
      console.error(`Roof estimation: Site ${siteId} not found`);
      return;
    }

    let result: googleSolar.RoofEstimateResult;

    if (site.latitude && site.longitude) {
      result = await googleSolar.estimateRoofFromLocation({
        latitude: site.latitude,
        longitude: site.longitude
      }, storage);
    } else {
      const fullAddress = [
        site.address,
        site.city,
        site.province,
        site.postalCode,
        "Canada"
      ].filter(Boolean).join(", ");

      if (!fullAddress || fullAddress === "Canada") {
        await storage.updateSite(siteId, {
          roofEstimateStatus: "skipped",
          roofEstimateError: "No address provided",
          roofEstimatePendingAt: null
        });
        return;
      }

      result = await googleSolar.estimateRoofFromAddress(fullAddress, storage);
    }

    if (!result.success) {
      await storage.updateSite(siteId, {
        roofEstimateStatus: "failed",
        roofEstimateError: result.error || "Could not estimate roof area",
        latitude: result.latitude || null,
        longitude: result.longitude || null,
        roofEstimatePendingAt: null
      });
      console.log(`Roof estimation failed for site ${siteId}: ${result.error}`);
      return;
    }

    const enrichedDetails = {
      ...result.details,
      maxSunshineHoursPerYear: result.maxSunshineHoursPerYear,
      roofSegments: result.roofSegments,
      googleProductionEstimate: result.googleProductionEstimate,
      panelCapacityWatts: result.panelCapacityWatts,
      maxArrayAreaSqM: result.maxArrayAreaSqM,
    };

    await storage.updateSite(siteId, {
      latitude: result.latitude,
      longitude: result.longitude,
      roofAreaAutoSqM: result.roofAreaSqM,
      roofAreaAutoSource: "google_solar",
      roofAreaAutoTimestamp: new Date(),
      roofAreaAutoDetails: enrichedDetails,
      roofEstimateStatus: "success",
      roofEstimateError: null,
      roofEstimatePendingAt: null
    });

    console.log(`Roof estimation success for site ${siteId}: ${result.roofAreaSqM.toFixed(1)} m²`);
  } catch (error) {
    console.error(`Roof estimation error for site ${siteId}:`, error);
    await storage.updateSite(siteId, {
      roofEstimateStatus: "failed",
      roofEstimateError: error instanceof Error ? error.message : "Unknown error",
      roofEstimatePendingAt: null
    });
  } finally {
    // Release lock
    roofEstimationLocks.delete(siteId);
  }
}
```

---

## 9. Fix Floating Point Precision

**Update `shared/finance/cashflowEngine.ts` to use integer cents:**

```typescript
/**
 * Round to cents and convert back to dollars
 * Prevents floating point accumulation errors
 */
function roundToCents(value: number): number {
  return Math.round(value * 100) / 100;
}

/**
 * Build the complete cashflow model for all financing scenarios
 */
export function buildCashflowModel(inputs: CashflowInputs): CashflowModel {
  const {
    systemSizeKW,
    annualProductionKWh,
    kwhCostPerWatt,
    hqIncentivePerKw,
    itcRate,
    gridRateY1,
    kwhInflation,
    trcInflation,
    degradation,
    omRate,
    omEscalation,
    ccaRate,
    taxRate,
    leaseTerm,
    leasePremium,
    ppaTerm,
    ppaDiscount,
    ppaOmRate,
    trcProjectCost
  } = inputs;

  // Calculate base values with rounding
  const grossCapex = roundToCents(systemSizeKW * 1000 * kwhCostPerWatt);
  const eligibleSolarKW = Math.min(systemSizeKW, 1000);
  const potentialHQIncentive = roundToCents(eligibleSolarKW * hqIncentivePerKw);
  const hqIncentive = roundToCents(Math.min(potentialHQIncentive, grossCapex * 0.4));
  const netAfterHQ = roundToCents(grossCapex - hqIncentive);
  const itc = roundToCents(netAfterHQ * itcRate);
  const netClientInvestment = roundToCents(netAfterHQ - itc);

  // Build yearly arrays
  const cashCashflows: YearlyCashflow[] = [];
  const leaseCashflows: YearlyCashflow[] = [];
  const ppaCashflows: YearlyCashflow[] = [];

  // Use integer cents internally for accumulation
  let cashCumulativeCents = Math.round(-netClientInvestment * 100);
  let leaseCumulativeCents = 0;
  let ppaCumulativeCents = 0;

  let ucc = netClientInvestment;
  const leasePayment = roundToCents(netClientInvestment / leaseTerm * (1 + leasePremium));

  const analysisPeriod = 25;

  for (let year = 1; year <= analysisPeriod; year++) {
    const production = roundToCents(annualProductionKWh * Math.pow(1 - degradation, year - 1));
    const gridRate = roundToCents(gridRateY1 * Math.pow(1 + kwhInflation, year - 1));
    const gridSavings = roundToCents(production * gridRate);
    const omCost = roundToCents(grossCapex * omRate * Math.pow(1 + omEscalation, year - 1));

    // CASH SCENARIO
    const ccaEffective = year === 1 ? ccaRate * 0.5 : ccaRate;
    const ccaDeduction = roundToCents(ucc * ccaEffective);
    const ccaBenefit = roundToCents(ccaDeduction * taxRate);
    ucc = roundToCents(ucc - ccaDeduction);

    const cashNet = roundToCents(gridSavings - omCost + ccaBenefit);
    cashCumulativeCents += Math.round(cashNet * 100);

    cashCashflows.push({
      year,
      production,
      gridRate,
      gridSavings,
      omCost,
      ccaBenefit,
      netCashflow: cashNet,
      cumulative: cashCumulativeCents / 100
    });

    // LEASE SCENARIO
    const leasePaymentThisYear = year <= leaseTerm ? leasePayment : 0;
    const leaseNet = roundToCents(gridSavings - omCost - leasePaymentThisYear);
    leaseCumulativeCents += Math.round(leaseNet * 100);

    leaseCashflows.push({
      year,
      production,
      gridRate,
      gridSavings,
      omCost,
      leasePayment: leasePaymentThisYear,
      netCashflow: leaseNet,
      cumulative: leaseCumulativeCents / 100
    });

    // PPA SCENARIO
    let ppaNet: number;
    let ppaPayment: number;

    if (year <= ppaTerm) {
      const trcRate = roundToCents(gridRateY1 * Math.pow(1 + trcInflation, year - 1) * (1 - ppaDiscount));
      ppaPayment = roundToCents(production * trcRate);
      ppaNet = roundToCents(gridSavings - ppaPayment);
    } else {
      const solarValue = roundToCents(production * gridRate);
      ppaPayment = roundToCents(solarValue * ppaOmRate);
      ppaNet = roundToCents(solarValue - ppaPayment);
    }
    ppaCumulativeCents += Math.round(ppaNet * 100);

    ppaCashflows.push({
      year,
      production,
      gridRate,
      gridSavings,
      omCost,
      ppaPayment,
      netCashflow: ppaNet,
      cumulative: ppaCumulativeCents / 100
    });
  }

  // Convert back to dollars
  const cashCumulative = cashCumulativeCents / 100;
  const leaseCumulative = leaseCumulativeCents / 100;
  const ppaCumulative = ppaCumulativeCents / 100;

  // Find payback years
  const findPaybackYear = (cashflows: YearlyCashflow[]): number | null => {
    const found = cashflows.find(cf => cf.cumulative >= 0);
    return found ? found.year : null;
  };

  const cashPayback = findPaybackYear(cashCashflows);
  const leasePayback = findPaybackYear(leaseCashflows);

  // Provider economics
  const providerCost = trcProjectCost || grossCapex;
  const providerHQ = roundToCents(Math.min(eligibleSolarKW * hqIncentivePerKw, providerCost * 0.4));
  const providerNetAfterHQ = roundToCents(providerCost - providerHQ);
  const providerITC = roundToCents(providerNetAfterHQ * itcRate);
  const providerNetInvestment = roundToCents(providerNetAfterHQ - providerITC);
  const providerCCAShield = roundToCents(providerNetInvestment * 0.26);
  const totalProviderIncentives = roundToCents(providerHQ + providerITC + providerCCAShield);

  const providerEconomics: ProviderEconomics = {
    grossCost: providerCost,
    hqIncentive: providerHQ,
    itc: providerITC,
    ccaShield: providerCCAShield,
    totalIncentives: totalProviderIncentives,
    actualInvestment: roundToCents(Math.max(0, providerCost - totalProviderIncentives))
  };

  const clientCCAShield = roundToCents(netClientInvestment * 0.26);
  const foregoneIncentives = roundToCents(hqIncentive + itc + clientCCAShield);

  const ppaPaybackIdx = ppaCashflows.findIndex(cf => cf.cumulative >= foregoneIncentives);
  const ppaPayback = ppaPaybackIdx >= 0 ? ppaPaybackIdx + 1 : null;

  return {
    inputs,
    grossCapex,
    hqIncentive,
    netAfterHQ,
    itc,
    netClientInvestment,
    cash: {
      name: "Comptant (kWh)",
      nameEn: "Cash (kWh)",
      investment: netClientInvestment,
      yearlyCashflows: cashCashflows,
      totalSavings: roundToCents(cashCumulative),
      avgAnnualSavings: roundToCents((cashCumulative + netClientInvestment) / analysisPeriod),
      paybackYear: cashPayback,
      ownershipYear: 1
    },
    lease: {
      name: "Crédit-bail (kWh)",
      nameEn: "Lease (kWh)",
      investment: 0,
      yearlyCashflows: leaseCashflows,
      totalSavings: roundToCents(leaseCumulative),
      avgAnnualSavings: roundToCents(leaseCumulative / analysisPeriod),
      paybackYear: leasePayback,
      ownershipYear: leaseTerm + 1
    },
    ppa: {
      name: "PPA",
      nameEn: "PPA",
      investment: 0,
      yearlyCashflows: ppaCashflows,
      totalSavings: roundToCents(ppaCumulative),
      avgAnnualSavings: roundToCents(ppaCumulative / analysisPeriod),
      paybackYear: ppaPayback,
      ownershipYear: ppaTerm + 1
    },
    providerEconomics,
    foregoneIncentives
  };
}
```

---

## 10. Centralized Upload Config

Already included in section 8 above as `server/lib/uploadConfig.ts`.

---

## Summary Checklist

After applying these fixes:

- [ ] Create `server/middleware/errorHandler.ts`
- [ ] Create `server/lib/secureRandom.ts`
- [ ] Create `server/lib/config.ts`
- [ ] Create `server/lib/uploadConfig.ts`
- [ ] Update `server/routes/public.ts` with state machine fix
- [ ] Add `getDesignAgreementByToken` to storage
- [ ] Update `server/routes/auth.ts` with secure password generation
- [ ] Update `server/routes/import.ts` with N+1 fix
- [ ] Update `server/routes/admin.ts` with path traversal fix
- [ ] Update `server/routes/sites.ts` with race condition fix
- [ ] Update `shared/finance/cashflowEngine.ts` with precision fix
- [ ] Update `server/index.ts` to use error handler middleware
- [ ] Run `npm run build` to verify TypeScript compilation
- [ ] Test all modified endpoints

---

## Notes for Replit

When you send this to Replit's agent, you can say:

> "Please apply these code fixes from the CODE_FIXES.md document. Create the new files first, then update the existing files in order. After each change, run `npm run build` to verify there are no TypeScript errors."

Good luck! Let me know if you need any clarification on any of these fixes.
